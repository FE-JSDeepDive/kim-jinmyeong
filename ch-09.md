자바스크립트의 모든 **값**은 타입이 있다. (변수가 아니라 값에 타입이 있음)

## 타입 변환

개발자가 의도적으로 타입을 변환하는 것을 명시적 타입 변환 혹은 **타입 캐스팅(type casting)**이라고 한다.

반대로 자바스크립트 엔진에 의해 타입을 변환하는 것을 묵시적 타입 변환 혹은 **타입 강제 변환(type coercion)**이라 한다.

## 타입 변환의 원리

원시 값은 immutable 하므로 타입을 변경한다는 것은 기존 원시 값을 사용해 다른 타입의 새로운 원시값을 생성하는 것이다.

## 타입 변환 패턴

- `+` 와 문자열 → 문자열
- 모든 산술 연산자 → 숫자 타입 | NaN(수로 계산할 수 없는 모든 타입들과의 연산의 경우)
- 비교 연산자 → 숫자타입으로 명시적 변환 → 이후 불리언으로 값 평가
- Truthy, Falsy → 불리언 타입

## 묵시접 타입 변환 예제

| 예시 | 연산 상황 | 결과 | 설명 |
| --- | --- | --- | --- |
| `"1" + 2` | 문자열과 숫자 결합 | `"12"` | `+` 연산자는 피연산자 중 하나라도 문자열이면 문자열 결합을 수행합니다. |
| `"1" - 2` | 문자열에서 숫자 빼기 | `-1` | 산술 연산자인 `-`는 문자열을 숫자로 암묵적 변환한 후 연산을 진행합니다. |
| `true + 1` | 불리언과 숫자 연산 | `2` | `true`는 숫자 `1`로 암묵적 변환되어 연산됩니다. |
| `false + 1` | 불리언과 숫자 연산 | `1` | `false`는 숫자 `0`으로 암묵적 변환됩니다. |
| `null + 1` | null과 숫자 연산 | `1` | `null`은 숫자 `0`으로 암묵적 변환되어 연산에 참여합니다. |
| `undefined + 1` | undefined와 숫자 연산 | `NaN` | `undefined`는 숫자 변환 시 `NaN`이 되어, 연산 결과가 정의되지 않습니다. |
| `"5" * "3"` | 문자열 곱셈 | `15` | 곱셈(`*`) 연산자는 문자열을 숫자로 변환한 후 연산을 수행합니다. |
| `"5" == 5` | 동등 비교 (==) | `true` | 동등 비교 연산자(`==`)는 피연산자들의 타입을 암묵적 변환 후 비교합니다. |
| `0 == false` | 동등 비교 (==) | `true` | `false`는 숫자 `0`으로 변환되어 비교됩니다. |
| `[1,2] + [3,4]` | 배열의 문자열 변환 및 결합 | `"1,23,4"` | 배열은 내부적으로 `toString()`을 호출하여 문자열로 변환된 후 결합됩니다. |

## 명시적 타입 변환 예시

| 예시 | 변환 방식 | 결과 | 설명 |
| --- | --- | --- | --- |
| `Number("123")` | 문자열 → 숫자 변환 | `123` | 문자열 `"123"`이 숫자 `123`으로 변환됩니다. |
| `Number("abc")` | 문자열 → 숫자 변환 | `NaN` | 숫자로 변환할 수 없는 문자열은 `NaN`이 됩니다. |
| `parseInt("42.99")` | 문자열 → 정수 변환 | `42` | `parseInt()`는 소수점 이하를 제거하고 정수로 변환합니다. ( 값타입 자체는 여전히 실수, 단순히 소숫점 이하 값을 제거함) |
| `parseFloat("42.99")` | 문자열 → 실수 변환 | `42.99` | `parseFloat()`는 소수점 이하까지 포함하여 변환합니다. |
| `String(100)` | 숫자 → 문자열 변환 | `"100"` | 숫자 `100`이 문자열 `"100"`으로 변환됩니다. |
| `(123).toString()` | 숫자 → 문자열 변환 | `"123"` | `toString()`을 사용하여 숫자를 문자열로 변환합니다. |
| `Boolean(1)` | 숫자 → 불리언 변환 | `true` | `1`은 `true`로 변환됩니다. |
| `Boolean(0)` | 숫자 → 불리언 변환 | `false` | `0`은 `false`로 변환됩니다. |
| `Boolean("hello")` | 문자열 → 불리언 변환 | `true` | 빈 문자열이 아닌 경우 `true`로 변환됩니다. |
| `Boolean("")` | 문자열 → 불리언 변환 | `false` | 빈 문자열은 `false`로 변환됩니다. |
| `Boolean(null)` | `null` → 불리언 변환 | `false` | `null`은 `false`로 변환됩니다. |
| `Boolean(undefined)` | `undefined` → 불리언 변환 | `false` | `undefined`는 `false`로 변환됩니다. |
| `JSON.stringify({a: 1})` | 객체 → JSON 문자열 변환 | `'{"a":1}'` | 객체를 JSON 문자열로 변환합니다. |
| `JSON.parse('{"a":1}')` | JSON 문자열 → 객체 변환 | `{a: 1}` | JSON 문자열을 객체로 변환합니다. |

## 객체 참조 오류 피하기

객체의 프로퍼티를 접근할 때 객체가 null 이나 undefined 인 경우 TypeError가 발생한다.
다만 몇몇 상황에서는 이러한 에러가 달갑지 않은 경우가 있다.

예를 들어,

- **API 응답이나 외부 데이터 처리 시**

  서버나 외부 데이터 소스에서 받아온 JSON 데이터가 항상 완전한 형태가 아닐 때, 예를 들어 사용자 데이터 객체에서 profile 정보가 누락되어 null 또는 undefined가 될 수 있습니다. 이때 profile 내부의 속성에 접근하면 에러가 발생합니다.

- **UI 렌더링 전 데이터 로딩 단계**

  React나 Vue와 같은 프레임워크에서 컴포넌트가 렌더링될 때, 비동기로 데이터를 받아오는 경우 초기에는 객체가 null이나 undefined일 수 있습니다. 이 상태에서 객체의 속성에 접근하면 TypeError가 발생해 애플리케이션이 중단될 위험이 있습니다.

- **깊게 중첩된 객체 구조 접근 시**

  중첩 객체에서 안전하게 값을 접근하고자 할 때, 중간 객체 하나라도 null이나 undefined인 경우 그 이후의 프로퍼티 접근은 에러를 발생시킵니다.


이러한 오류를 피하기 위한 방법으로는 크게 3가지가 있다.

- 단축평가
- 옵셔널 연산자 `?`
- null 병합 연산자 `??`

### 단축 평가 (short-circuit evaluation)

**`&&` `||` 와 같은 논리 연산자는 논리 연산의 결과를 결정한 첫 번째 피연산자를 타입 변환하지 않고 그대로 반환한다. 그리고 논리 연산의 결과가 확정된 경우 나머지 평과 과정을 생략하는데 이를 단축 평가라고 한다.**

```tsx
var elem = null;
var value = elem && elem.value;
```

단축 평가를 이용해 TypeError를 발생시키지 않는다.
elem이 null이나 undefined라면 elem은 Falsy로 평가되고 더이상 연산을 진행하지 않는다. (elem.value 까지 평가하지 않는다.) 반대로 elem이 값이 있다면 elem.value 의 값이 평가되어 변수에 할당된다.

<aside>
💡

조건의 결과가 이미 결정되면 나머지 표현식을 평가하지 않는 것이 단축 평가의 핵심입니다. 그런데 JavaScript의 && 연산자는 단축 평가를 수행하면서도 **반환 값**에 있어서는 단순히 true나 false가 아닌 피연산자 중 하나를 그대로 반환합니다.

if문은 표현식의 결과를 명시적으로 true나 false로 반환하지 않더라도, 그 결과를 불리언 컨텍스트로 평가합니다.

예를 들어,

```jsx
if (elem && elem.value) {
  // 코드 실행
}
```

이 경우, `elem && elem.value` 연산의 결과가 실제 피연산자 값(예: `null` 또는 `elem.value`)으로 반환되지만, if문 내부에서는 그 값이 truthy인지 falsy인지에 따라 실행 여부가 결정됩니다. 즉, 반환값이 Boolean 타입이 아니더라도 불리언 컨텍스트에서 평가되어 if문의 조건으로 사용됩니다.

</aside>

이러한 특징을 이용하여 단일 조건문을 단일 조건식으로 대체할 수 있다.

```tsx
var done = true;
var message = '';

if (done) message = '완료';
// 위 if문은 아래처럼 단축평가를 이용해 대체할 수 있음
message = done && '완료'; 
```

`&&` 연산자를 통해 조건을 식으로하여 (값으로 평가하여) 변수에 값을 할당할 수 있다.

```tsx
var done = false;
var message = '';

if (!done) message = '미완료';
// 위 if문은 아래처럼 단축평가를 이용해 대체할 수 있음
message = done || '미완료'; 
```

`||` 연산자는 부정문을 대체할 수 있다.

else가 포함된 조건문의 경우에는 삼항 연산자를 통해 식으로 평가할 수 있다.

---

이러한 특징을 이용하면 `||` 를 통해 기본값을 설정할 수 있다.

```tsx
function getStringLength(str) {
	str = str || '';
	return str.length;
}

getStringLength();  // -> 0
getStringLength('hi')  // -> 2
```

ES6 부터는 매개변수에 기본값 설정도 가능

```tsx
function getStringLength(str = '') {
	return str.length;
}

getStringLength();  // -> 0
getStringLength('hi')  // -> 2
```

### 옵셔널 연산자

객체를 가리키기를 기대하는 변수가 `null` 또는 `undefined` 가 아닌지 확인하고 프로퍼티를 참조할 때 유용

오로지 `null` , `undefined` 인 경우만 우항의 프로퍼티 참조를 멈추고 그 외의 모든 Falsy들은 그대로 참조한다

```tsx
var str = '';
var length = str && str.length;

console.log(length); // ''
```

위와 같은경우 문자열의 길이가 0임을 기대하지만 단축평가의 경우 str에서 Falsy로 이미 끝났기 때문에 str의 리턴값인 ‘’가 변수에 할당된다.

```tsx
var str = '';
var length = str?.length;

console.log(length); // 0
```

옵셔널 연산자의 경우 null 이나 undefined가 아니라면 우항의 프로퍼티 참조를 이어가므로 기대하는 0을 받아서 변수에 할당할 수 있다.

---

### null 병합 연산자

좌항의 피연산자가 오로지 `null` , `undefined` 인 경우만 우항의 피연산자를 반환하고 그렇지 않으면 좌항의 피연산자를 반환한다. 기본값을 설정할 때 유용하다.

마찬가지로 `||`  를 통한 기본값 설정의 오작동을 보완할 수 있는데

```tsx
var foo = '' || 'default string';
console.log(foo); // 'default string';
```

foo는 빈 문자열이 할당되었지만 빈문자열은 Falsy로 평가되어 foo에 빈문자열 아닌 우항 피연산자가 할당되는 문제가 있다.

```tsx
var foo = '' ?? 'default string';
console.log(foo); // ''
```

null 병합 연산자를 사용하면 의도에 맞게 사용할 수 있다.

논리 연산자(+단축 평가)를 통해 null, undefined 를 대응하고자 하는 경우에는 옵셔널 연산자와 null 병합 연산자를 사용하는것이 더 의도에 맞게 사용할 수 있다. ( 일반적으로 값을 받지 못했다고 기대하는건 null과 undefined 이지 빈문자열과 0은 아니기 때문 )