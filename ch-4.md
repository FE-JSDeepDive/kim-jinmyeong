⚠️ 용어를 정확히 사용하기 <br>
⚠️ 단순히 넣는다 저장한다로 퉁치지 않기
## 변수란?
**`Variable`**

- 프로세서가 연산할 수 있도록 확보한 메모리 공간이자 해당 공간을 식별하기 위해 붙인 이름

---

## 선언

1. 값을 저장하기 위한 메모리 공간을 확보한다.
2. 변수 이름과 확보된 메모리 공간의 주소를 연결한다.

위 일련의 행동을 **변수를 선언**한다고 한다.
<br>→ 이렇게 확보한 메모리 공간에는 추후에 어떤 값을 저장할 수 있다.
<br>→ 개발자는 이렇게 확보한 메모리 공간을 변수 이름(식별자)를 통해 접근하여 값을 사용할 수 있다.

**선언 방법** <br>
변수를 선언하기 위해서는 `var` , `let`, `const` 키워드를 사용한다.
위 키워드 뒤에 임의의 리터럴을 붙이면 해당 리터럴이 변수의 이름(=특정 메모리 공간의 식별자)가 된다.

```jsx
let example;
```

---

## 할당

위처럼 선언을 통해 만들어진 메모리 공간에는 값이 저장되어있지 않다.
`=` 라는 연산자를 통해 메모리 공간에 값을 저장할 수 있다.

```jsx
let example = 100;
```

선언 후에 값이 아직 할당되지 않은 경우가 있는데 자바스크립트에서는 선언 직후에 `undefined` 라는 원시 값을 할당한다. 이는 메모리 공간은 확보되었지만 값이 할당되지 않았다는 초기 상태를 의미하는 값으로 사용된다.
<br>→ 따라서 기본적으로는 `null` 과 구분된다.
<br>→ `null` 은 개발자가 의도적으로 값이 들어있지 않음을 나타내고 싶은 값이고 `undefined` 는 할당과정 없이 선언만 된 변수임을 나타낸다. (즉, undefined 가 오류일 확률이 더 높다.)

### 재할당

이미 할당되어 값을 저장하고 있는 변수에 새로운 값을 저장하는 행위를 말한다.
단, `const` 키워드의 경우에는 재할당이 불가능하다. (=상수)

재할당 할 때는 기존 할당되어있는 메모리 공간의 값을 지우고 다시 쓰는 것이 아닌 새로운 메모리 공간을 확보하고 그 공간에 새로운 값을 저장하고 참조한다. 그리고 재할당 이전에 확보되었던 메모리 공간들은 (다른 곳에서 참조하고 있지 않는다면) 주기적으로 다시 해제하여 낭비되는 메모리 공간이 없도록 한다. 자바스크립트에서는 이러한 기능을 제공하고 있으며 **가비지 컬렉터**라고 부른다. ****

---

## 초기화

변수 선언과 할당이 동시에 이루어지는 경우 이를 초기화라고 부른다.

```jsx
let foo = 'Hello world!';
```

따라서 선언만 하더라도 자바스크립트가 암묵적으로 undefined 값을 할당하므로 모든 선언은 undefined로 초기화 된다고 표현할 수도 있다.

<aside>
💡
모든 선언은 암묵적으로 undefined 값이 할당되는 초기화나 마찬가지이기 때문에 사실 선언 이후 값을 할당하는 행위는 모두 재할당이나 다름없다.
그렇기 때문에 재할당을 금지하는 `const`  키워드는 선언만 할 수 없고 초기값을 명시적으로 지정해야한다. 초기값 없이 단순히 선언만하면 이미 undefined 가 할당된 것이고 재할당이 불가능하기 때문에 사실상 변수로서의 의미를 상실하기 때문이다. (그래서 자바스크립트에서는 초기값없이 `const` 로 선언하는 동작을 문법 오류로 정의해둠)

</aside>

---

## 변수 호이스팅

코드의 평가 시점과 실행 시점이 달라 (눈에 보이는 코드상으로) 선언되지 않은 변수를 접근할 때 에러를 뱉지 않는 현상을 말한다.

예를 들어

```jsx
console.log(bar); // -> Reference Error가 날 것 같지만 undefined를 출력한다.

var bar;
```

`bar` 변수는 코드상으로 bar보다 더 늦게 선언되었음에도 불구하고 console이 `bar` 를 사용할 때는 bar 변수가 초기화 되어있는 모습을 확인할 수 있다.

이는 자바스크립트 엔진이

1. 코드에 존재하는 모든 변수를 초기화하고 컨택스트에 저장
2. 자바스크립트 코드를 순차적으로 실행(런타임)함

의 순서로 진행되기 때문이다.

<aside>
⚠️
하지만 연산자는 실행할 때 평가된다.
이는 할당 연산자인 `=` 도 마찬가지인데 이러한 특징 때문에 선언과 할당을 동시에 하지만 선언이 먼저되고 값 할당은 런타임에 진행되어 혼란을 야기할 수 있으니 주의가 필요하다.

```jsx
console.log(example); 

let example = 100;
```

example 변수가 선언되는 동작이 먼저 실행되었으니 console.log는 undefined를 출력한다.
하지만 할당 연산자는 런타임에 순차적으로 실행되므로 console.log() 보다 이후에 평가된다.
따라서 Reference Error도 100이라는 출력도 찍히지 않는다.

</aside>